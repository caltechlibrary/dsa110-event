import json
from os import environ, path
import datetime
try:
    from datacite import DataCiteRESTClient
except ImportError:
    print('datacite not found. cannot create DOIs')
try:
    from caltechdata_api import caltechdata_edit, caltechdata_write
except ImportError:
    print('caltechdata_api not found.')

try:
    dcp = environ['DATACITEPWD']
    token = environ['TINDTOK']
except KeyError:
    dcp = None
    token = None
    print('Secrets not found. Cannot use datacite API')

_install_dir = path.abspath(path.dirname(__file__))


def send_ctd(dictin={}, doi=None, internalname=None, filenames=[], production=False, schema='43'):
    """ Create entry at Caltech Data.
    dictin overloads fields in template dictionary.
    filenames is (optional) list of strings with full path to file for upload.
    Upload takes time, so can be left blank and loaded alter via "edit_ctd" function.
    """

    metadata = set_metadata(dictin, internalname=internalname, doi=doi, schema=schema)

    # write metadata
    res = caltechdata_write(metadata, token, filenames=filenames, production=production, schema=schema)
    Id = res.rstrip('. ').split('/')[-1]

    return Id


def edit_ctd(Id, metadata={}, filenames=[], production=False):
    """ Edit an entry at Caltech Data.
    metadata can be emtpy dict ({}) and filenames a list of files associate with existing Id.
    filenames is list of strings with full path to file for upload.
    """
    
    # upload supporting data
    caltechdata_edit(token, Id, metadata=metadata, filenames=filenames, production=production)


def set_metadata(dictin=None, internalname=None, doi=None, schema='43'):
    """ Create dict with metadata for caltechdata/datacite.
    dictin overloads fields in template fields.
    internalname is optional name for event.
    doi can be provided, but if not, one will be generated.
    schema can be '43' or '42' and defines template json file.
    """

    # template metadata
    with open(path.join(_install_dir, f'data/example{schema}.json'), 'r') as fp:
        metadata = json.load(fp)

    # overload metadata
    if dictin is not None:
        for key, value in dictin.items():
            if key in metadata:
                print(f'Overloading metadata key {key} with {value}')
                metadata[key] = value

    # modify basic metadata
    if internalname is not None:
        metadata['alternateIdentifiers'] = [{'alternateIdentifier': internalname,
                                             'alternateIdentifierType': '?'}]
    dt = datetime.datetime.now()
    metadata['publicationYear'] = f'{dt.year:04}'
    metadata['dates'] = [{'date': f'{dt.year:04}-{dt.month:02}-{dt.day:02}', 'dateType': 'Created'}]  # dateType can also be "Updated"
    #    metadata['formats'] = ['FITS', 'filterbank', 'png']  # or just one zip?

    # can provide doi or have one generated by datacite
    if doi is None:
        doi = get_doi(metadata)  # TODO: check whether it is returned or just added to metadata dict
    metadata['identifiers'] = [{'identifier': doi, 'identifierType': 'DOI'}]

    return metadata


def get_doi(metadata, production=False):
    """ Use datacite to get DOI for metadata
    """

    # development
    dcprefix_dev = '10.22013'
    dcurl_dev = 'http://doi.test.datacite.org'
    # production
    dcprefix_prod = '10.26800'
    dcurl_prod = 'http://doi.datacite.org'

    if production:
        url = dcurl_prod
        prefix = dcprefix_prod
    else:
        url = dcurl_dev
        prefix = dcprefix_dev

    d = DataCiteRESTClient(username='CALTECH.OVRO', password=dcp, prefix=prefix, test_mode=(not production))
    return d.public_doi(metadata, url)
